def main(x):
    if x < 10:
        return 91 * pow(math.tan(x), 6)
    elif 10 <= x < 26:
        return pow(x, 4) / 73
    elif 26 <= x < 122:
        return (pow(x, 4)) / 39
    elif 122 <= x < 209:
        return 51 * pow(x, 2) - 32 * pow(x, 7)
    elif x >= 209:
        return pow(abs(10 * pow(x, 3)), 3)

    if n == 0:
        return -0.94
    elif n == 1:
        return 0.90
    elif n >= 2:
        return pow(math.sin(53 * main(n-2) + pow(main(n - 1), 3)), 2)


def main(n):
    sm = 0
    for i in range(0, len(n)):
        sm += 2 * (74 * n[i] + 68 + pow(n[i], 2))
    return 64 * sm

from typing import List


derevo = {
    "OX": {
        "DM": {
            "1978": 0,
            "1960": 1,
            "1958": 2
        },
        "VOLT": {
            "1978": 4,
            "1960": 5,
            "1958": 6
        },
        "XPROC": 3,
    },
    "PLSQL": {
        "DM": 8,
        "XPROC": 9,
        "VOLT": 10
    },
    "RHTML": 7
}


def main(arr: List) -> int:
    global derevo
    a = derevo
    while True:
        for item in arr[::-1]:
            k = str(item)
            if k in a.keys():
                a = a[k]
            if isinstance(a, int):
                return a

print(main(['1960', 'OX', 'DM' , 'EC']))


def main(num):
    a = num & 0b0000000000000000000000000011111
    b = num & 0b0000000000011111111111111100000
    c = num & 0b0000011111100000000000000000000
    d = num & 0b1111100000000000000000000000000
    return (a << 5) | (b << 5) | (c << 5) | (d >> 26)

print(hex(main(0xd539747f)))


def main(input):
    a = (input & 0b0000000000000000000000000011111) << 5
    b = (input & 0b0000000000011111111111111100000) << 5
    c = (input & 0b0000011111100111110000000000000) << 5
    d = (input & 0b1111111111111000000000000000000) >> 26
    return a | b | c | d
print(hex(main(0xd539747f)))

from enum import Enum


class State(Enum):
    A = 0
    B = 1
    C = 2
    D = 3
    E = 4
    F = 5


class StateMachine:
    state = State.A

    def warp(self):
        return self.update({
            State.A: [State.B, 0],
            State.B: [State.C, 1],
            State.C: [State.D, 3],
            State.D: [State.E, 5],
            State.E: [State.F, 6],
        })

    def skew(self):
        return self.update({
            State.B: [State.E, 2],
            State.C: [State.C, 4],
            State.E: [State.C, 7],
            State.F: [State.D, 8],
        })

    def update(self, transitions):
        self.state, signal = transitions[self.state]
        return signal


def main():
    return StateMachine()


main()


import math


def main(n):
    sm = 0
    for i in range(0, len(n)):
        sm += 2 * (74 * n[i] + 68 + pow(n[i], 2))
    return 64 * sm

print('{0:.2e}'.format(main([-0.05 , 0.35, -0.7, -0.61, 0.69])))
